<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> 第一章 Avalanche共识协议介绍</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> 第二章 AvalancheGo结构分析</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_2.1.html"><strong aria-hidden="true">2.1.</strong> snowman协议</a></li><li class="chapter-item expanded "><a href="chapter_2.2.html"><strong aria-hidden="true">2.2.</strong> snowman协议实现解析</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> 第三章 Subnet by rust</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> 第四章 Subnet by go</a></li><li class="chapter-item expanded "><a href="Go-Plugin/hashicorpGoPlugin.html"><strong aria-hidden="true">5.</strong> Hashicop Go Plugin</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第一章-avalanche共识协议介绍"><a class="header" href="#第一章-avalanche共识协议介绍">第一章 Avalanche共识协议介绍</a></h1>
<p>Avalanche共识协议一种抽样投票基于亚稳态机制（metastable）的共识协议族，亚稳态是Avalanche协议的一个主要原理，它是通过传递“信任阈值”来达成共识。这种信任阈值通过网络传播，结构化和验证信息。亚稳态通常在高可用性数据库中可以看到达到共识结果的法定人数，其中还包含有助于系统快速达成共识的其他结构信息。为了有效地在网络上传播信息，单个节点将信息x传播到n个节点的网络中的法定数量k个节点，然后又将x传播到另一个法定数量k个节点。在分布系统中，对于接受和验证信息x是会存在相反意见的，人们希望协议的信任阈值的大小值是整个K节点中有超过2/3k的多数节点。因此，与传统的基于gossip协议的共识协议的显着区别在于亚稳态通过法定节点数量传播信息，而不是通过单个节点之间互相传播信息，从而保持整体较低的通信成本。
Avalanche共识协议具体来说是一个协议族，主要包含Slush、flake、snowball、avalanche四种共识算法。
这个共识协议族有绿色、安静、高效的特点。绿色（Green）消耗很少能源；安静（Quiescent）没有交易时不需要工作（相对比特币，比特币在没有交易的时候矿工也要不断工作）；高效（Efficient）节点交互复杂度O(knlogn) ~ O(kn)。
Avalanche共识算法有以下特点：
1、并行共识模型：不使用单一复制状态机（RSM）模型，每个节点维护自己的RSM（可以互相转移所有权），系统对有关联的交易只维护偏序（partial order）
2、反复随机采样：引导正常节点产生相同输出
3、亚稳态决策：亚稳态决策可以使得一个大网络快速推进到一个不可逆的状态（虽然不能100%保证）
此外，该共识协议提出的算法可以提供强概率安全性保证，并且保证诚实节点的活性。所谓“强概率安全保证”，是指共识被逆转的可能性小到可以被忽略（甚至小于哈希冲突的概率），实际上比特币的POW提供的也是强概率安全性保证。该共识协议理论分析通过了实验验证，实验结果和理论分析基本吻合。
目前，Avalanche协议最典型的实现版本是AvalancheGO，也是Ava Lab实验室的官方实现版本。本书实践内容均是基于AvalancheGo实现。</p>
<h2 id="共识接口抽象封装"><a class="header" href="#共识接口抽象封装">共识接口（抽象封装）</a></h2>
<p>snowman.Consensus接口是一个封装成可以处理独立事务（单个block）并实现共识的功能模块，主要接口功能有：</p>
<p>【1】NumProcessing() int
返回当前共识处理区正在处理的区块数量；</p>
<p>【2】Add(Block) error
向共识处理区中加入新的区块（待加入共识）</p>
<p>【3】
AcceptedOrProcessing(Block) bool  #判断某一区块是否已被接受或在处理中
DecidedOrProcessing(Block) bool    #判断某一区块是否已被决定（被接受或者被拒绝）或在处理中
IsPreferred(Block) bool                    #判断某一区块是否是最佳候选分支上的区块</p>
<p>【4】
Preference() ids.ID
获取当前节点最佳候选分支的最末端区块</p>
<p>【5】
RecordPoll(ids.Bag) error
将网络投票结果进行统计计算并进行相关处理</p>
<p>【6】
Finalized() bool                               #判断共识处理区是否还有带处理的共识
HealthCheck() (interface{}, error)     #返回共识处理区的运行健康情况
// Consensus represents a general snowman instance that can be used directly to
// process a series of dependent operations.
type Consensus interface {
// Takes in the context, snowball parameters, and the last accepted block.
Initialize(
ctx *snow.ConsensusContext,
params snowball.Parameters,
lastAcceptedID ids.ID,
lastAcceptedHeight uint64,
) error</p>
<pre><code>// Returns the parameters that describe this snowman instance
Parameters() snowball.Parameters

// Returns the number of blocks processing
NumProcessing() int

// Adds a new decision. Assumes the dependency has already been added.
// Returns if a critical error has occurred.
Add(Block) error

// AcceptedOrProcessing returns true if the block has been accepted or is
// currently processing
AcceptedOrProcessing(Block) bool

// DecidedOrProcessing returns true if the block has been decided or is
// currently processing.
DecidedOrProcessing(Block) bool

// IsPreferred returns true if the block is currently on the preferred
// chain.
IsPreferred(Block) bool

// Returns the ID of the tail of the strongly preferred sequence of
// decisions.
Preference() ids.ID

// RecordPoll collects the results of a network poll. Assumes all decisions
// have been previously added. Returns if a critical error has occurred.
RecordPoll(ids.Bag) error

// Finalized returns true if all decisions that have been added have been
// finalized. Note, it is possible that after returning finalized, a new
// decision may be added such that this instance is no longer finalized.
Finalized() bool

// HealthCheck returns information about the consensus health.
HealthCheck() (interface{}, error)
</code></pre>
<p>}</p>
<h2 id="snowman协议具体实现"><a class="header" href="#snowman协议具体实现">snowman协议具体实现</a></h2>
<p>【1】snowman.Topological 是一个实现了snowman.Consensus接口的一个struct；
【2】其中包含了对snowmanBlock的操作，维持有一个 字典结构   blocks map[ids.ID]*snowmanBlock；
【3】snowmanBlock中用到了 snowball.Consensus的实例 snowball.Tree{}，snowball.Consensus实现了具体的avalanche共识算法。</p>
<p>在snowman.Consensus层面：主要负责向Topological结构中加入block，同时从合规网络中抽取投票结果并把结果传递给Consensus实现结构Topological.具体共识计算由snowman.block来计算。</p>
<p>snowman.snowmanBlock是Avalanche共识算法区块化部分，这个结构体主要是通过打包几个关键结构来起到整合的作用，该结构体只有两个方法，AddChild(child Block)和Accepted()， snowman.snowmanBlock具体封装如下：</p>
<p>// Tracks the state of a snowman block 用于跟踪维护snowman.Block的状态（是否被接受/拒绝等）
type snowmanBlock struct {
sm Consensus   // pointer to the snowman instance this node is managed by	
blk Block  // block that this node contains. For the genesis, this value will be nil
shouldFalter bool // shouldFalter is set to true if this node, and all its descendants received less than Alpha votes</p>
<pre><code>// sb is the snowball instance used to decided which child is the canonical
// child of this block. If this node has not had a child issued under it,
// this value will be nil
sb snowball.Consensus

// children is the set of blocks that have been issued that name this block
// as their parent. If this node has not had a child issued under it, this value
// will be nil
children map[ids.ID]Block //区块 Block中只有Parent，没有children，此处记录Children是
</code></pre>
<p>} //由于avalanche共识协议中利用区块父子关系进行连坐制实现批量抽样投票所需。</p>
<h2 id="snowball详解"><a class="header" href="#snowball详解">snowball详解</a></h2>
<p>snowball.Consensus接口定义了一个snowball的具体实现方法和逻辑，表示可以直接用啦处理网络投票结果的功能模块。本质是承接了共识计算统计功能：根据给定安全系数来计算处理网络投票结果，最终确定该投票是否已经是全网共识的结果。</p>
<p><em>注意</em> 投票结果在给到snowball的前提条件是：
【1】所投票的内容是符合VM逻辑的；
【2】投票来源是P链提供的符合规定的节点（随机抽取）</p>
<p>此处以线性区块链作为案例：一个投票对象就是一个snowball,所以每一个区块在处理的时候都是以接口主要方法有（不全）：
Add(newChoice ids.ID) 
#添加一个候选区块
RecordPoll(votes ids.Bag)
#统计一次投票结果
RecordUnsuccessfulPoll()
#针对投票失败（即没有达到α票数），这时需要对累加器置零（Avalanche共识算法规定）</p>
<h2 id="共识引擎核心功能为共识算法统筹投票结果"><a class="header" href="#共识引擎核心功能为共识算法统筹投票结果">共识引擎核心功能—为共识算法统筹投票结果</a></h2>
<p>Blockable
// Blockable defines what an object must implement to be able to block on events
一个对象，可以被events.Blocker阻塞管理的对象。
type Blockable interface {
Dependencies() ids.Set  // IDs that this object is blocking on
Fulfill(ids.ID) // Notify this object that an event has been fulfilled
Abandon(ids.ID) // Notify this object that an event has been abandoned
Update() // Update the state of this object without changing the status of any events
}
【Blockable小结】Blockable可以根据特定依赖条件来出发特定的动作。简单实现事件驱动机制。以下结构均实现了该接口功能：
snowman.voter：当接收到一个chit时，engine不会立即进行记录，会先查看等待其依赖条件是否满足，满足条件后voter才会开始调用记录chit功能模块。
snowman.issuer: 当依赖条件满足时，issuer 会将一个区块发往共识处理区。
snowman.convincer：当条件达到时，会发送一个chits到一个特定的validator note.</p>
<p>Blockable接口实列voter
通过voter.Update()来调用Transitive的polls.Vote()来计算结果，并将结果传递给snowman.RecordPoll(ids.Bag) error。
在继续下一步之前，需要将poll进一步解剖【详见《poll具体实现》】</p>
<p>events.Blocker</p>
<p>event.voter :事件驱动模式，在满足条件的情况下会调用transitive中topological(snowman.Consensus)的RecordPoll(result)</p>
<h2 id="poll解析"><a class="header" href="#poll解析">Poll解析</a></h2>
<p>poll.Poll接口
表示一轮投票poll，每一轮poll确定好要随机取样的节点（随机K个，有可能有一个点被重复取样一次以上），poll完成(收集到α个相同的投票)后即可以进入topological(snowman.Consensus实现实列) recordpoll(ID).
type Set interface {
fmt.Stringer
Add(requestID uint32, vdrs ids.ShortBag) bool
Vote(requestID uint32, vdr ids.ShortID, vote ids.ID) []ids.Bag
Drop(requestID uint32, vdr ids.ShortID) []ids.Bag
Len() int
}
两个实现主要是finished条件不一样：
【实现一】earlyTermNoTraversalPoll #当剩下的validators已经无法改变该结果的时候就finishes.
type earlyTermNoTraversalPoll struct {
votes  ids.Bag             #选票数量统计，初始为0
polled ids.ShortBag   #投票人，每一个poll在创建的时候就确定好目标投票人（从P链中的节点随机选出k个）
alpha  int                   #α
}
【实现二】noEarlyTermPoll #所有的validators要么有回应，要么超时才finishes.
type noEarlyTermPoll struct {
votes  ids.Bag
polled ids.ShortBag
}
abc</p>
<p>【1】在AvalancheGo实现中，有一个参数：transitive.Params.ConcurrentRepolls用于同时进行网络poll的数量，即可以同时进行poll。(此处不清楚该操作是否会对网络安全有影响，待进一步参考相关资料)
【2】每一次poll都是直接发送pullQuery(prefID),只发送当前prefID.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第二章-avalanchego结构分析"><a class="header" href="#第二章-avalanchego结构分析">第二章 AvalancheGo结构分析</a></h1>
<p>Avalanche采用了独特的三层网络结构，将执行环境和链本身分开，分为X链（交易链）、P链（平台链）、C链（合约链）。整个Avalanche网络依赖「雪」系列共识协议运行，该系列协议结合了拜占庭共识协议和工作量证明协议，衍生出了雪崩（Avalanche）、雪人（Snowman）和霜白（Frosty）三部分协议，其中X链使用雪崩协议，P链和C链使用雪人协议。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="snowman协议"><a class="header" href="#snowman协议">snowman协议</a></h2>
<p>用于单链式结构的的共识协议，Subnet也是由snowman协议引擎驱动运行。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="snowman协议实现解析"><a class="header" href="#snowman协议实现解析">snowman协议实现解析</a></h2>
<p>【二】接口实现
Topological 结构实现了 Snowman.Consensus接口，通过一颗树结构来实现对最大意向分支的跟踪维护，具体实现如下。
type Topological struct {
metrics.Latency
metrics.Polls
pollNumber uint64 // pollNumber is the number of times RecordPolls has been called	
ctx *snow.ConsensusContext // ctx is the context this snowman instance is executing in
params snowball.Parameters // params are the parameters that should be used to initialize snowball instances
head ids.ID // head is the last accepted block</p>
<pre><code>// height is the height of the last accepted block
height uint64

// blocks stores the last accepted block and all the pending blocks
blocks map[ids.ID]*snowmanBlock // blockID -&gt; snowmanBlock

// preferredIDs stores the set of IDs that are currently preferred.
preferredIDs ids.Set //preferred 分支上所有block的id的集合

// tail is the preferred block with no children
tail ids.ID

// Used in [calculateInDegree] and.
// Should only be accessed in that method.
// We use this one instance of ids.Set instead of creating a
// new ids.Set during each call to [calculateInDegree].
leaves ids.Set
//leaves和kahnNodes只用于临时存储，只在调用calculateInDegree的时候使用，只是面对一个voteBag
// Kahn nodes used in [calculateInDegree] and [markAncestorInDegrees].
// Should only be accessed in those methods.
// We use this one map instead of creating a new map
// during each call to [calculateInDegree].
kahnNodes map[ids.ID]kahnNode
</code></pre>
<p>}</p>
<div style="break-before: page; page-break-before: always;"></div><p><a href="https://crates.io/crates/timestampvm"><img alt="crates.io" src="https://img.shields.io/crates/v/timestampvm.svg?style=for-the-badge&color=fc8d62&logo=rust" height="20"></a>
<a href="https://docs.rs/timestampvm"><img alt="docs.rs" src="https://img.shields.io/badge/docs.rs-timestampvm-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs" height="20"></a>
<img src="https://github.com/ava-labs/timestampvm-rs/actions/workflows/test-and-release.yml/badge.svg" alt="Github Actions" /></p>
<h1 id="timestampvm-rs"><a class="header" href="#timestampvm-rs"><code>timestampvm-rs</code></a></h1>
<p><code>timestampvm-rs</code> is a virtual machine that can build blocks from a user-provided arbitrary data. It is a minimal implementation of an Avalanche custom virtual machine (VM) in Rust, using the Avalanche <a href="https://github.com/ava-labs/avalanche-types-rs">Rust SDK</a>.</p>
<p>Currently, Avalanche custom VM requires the following:</p>
<ol>
<li>Compiled to a binary that <code>avalanchego</code> can launch as a sub-process.</li>
<li>Plugin binary path in hash of 32 bytes.</li>
<li>Implements <a href="https://pkg.go.dev/github.com/ava-labs/avalanchego/snow/engine/snowman/block#ChainVM"><code>snowman.block.ChainVM</code></a> interface that can be be registered via <a href="https://pkg.go.dev/github.com/ava-labs/avalanchego/vms/rpcchainvm#Serve"><code>rpcchainvm.Serve</code></a>.</li>
<li>Implements VM-specific services that can be served via URL path of the blockchain ID.</li>
<li>(Optionally) Implements VM-specific static handlers that can be served via URL path of the VM ID.</li>
</ol>
<p>For example, the timestamp VM can be run as follows:</p>
<pre><pre class="playground"><code class="language-rust">use avalanche_types::subnet;
use timestampvm::vm;
use tokio::sync::broadcast::{self, Receiver, Sender};

#[tokio::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    let (stop_ch_tx, stop_ch_rx): (Sender&lt;()&gt;, Receiver&lt;()&gt;) = broadcast::channel(1);
    let vm_server = subnet::rpc::vm::server::Server::new(vm::Vm::new(), stop_ch_tx);
    subnet::rpc::plugin::serve(vm_server, stop_ch_rx).await
}</code></pre></pre>
<p>See <a href="timestampvm/src/bin/timestampvm/main.rs"><code>bin/timestampvm</code></a> for plugin implementation and <a href="tests/e2e/src/tests/mod.rs"><code>tests/e2e</code></a> for full end-to-end tests.</p>
<h2 id="avalanchego-compatibility"><a class="header" href="#avalanchego-compatibility">AvalancheGo Compatibility</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Version(s)</th><th>AvalancheGo Version(s)</th></tr></thead><tbody>
<tr><td>v0.0.6</td><td>v1.9.2,v1.9.3</td></tr>
<tr><td>v0.0.7</td><td>v1.9.4</td></tr>
</tbody></table>
</div>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code class="language-bash"># build the timestampvm plugin, run e2e tests, and keep the network running
./scripts/build.release.sh \
&amp;&amp; VM_PLUGIN_PATH=$(pwd)/target/release/timestampvm \
./scripts/tests.e2e.sh

# or, specify the custom avalanchego binary
./scripts/build.release.sh \
&amp;&amp; VM_PLUGIN_PATH=$(pwd)/target/release/timestampvm \
./scripts/tests.e2e.sh ~/go/src/github.com/ava-labs/avalanchego/build/avalanchego

# (optional) set NETWORK_RUNNER_ENABLE_SHUTDOWN=1 in &quot;tests.e2e.sh&quot;
# to shut down the network afterwards
</code></pre>
<p>To test <code>timestampvm</code> APIs, try the following commands:</p>
<pre><code class="language-bash"># &quot;tGas3T58KzdjcJ2iKSyiYsWiqYctRXaPTqBCA11BqEkNg8kPc&quot; is the Vm Id
# e.g., timestampvm vm-id timestampvm
curl -X POST --data '{
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;id&quot;     : 1,
    &quot;method&quot; : &quot;timestampvm.ping&quot;,
    &quot;params&quot; : []
}' -H 'content-type:application/json;' 127.0.0.1:9650/ext/vm/tGas3T58KzdjcJ2iKSyiYsWiqYctRXaPTqBCA11BqEkNg8kPc/static

# {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:{&quot;success&quot;:true},&quot;id&quot;:1}
</code></pre>
<pre><code class="language-bash"># &quot;2wb1UXxAstB8ywwv4rU2rFCjLgXnhT44hbLPbwpQoGvFb2wRR7&quot; is the blockchain Id
curl -X POST --data '{
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;id&quot;     : 1,
    &quot;method&quot; : &quot;timestampvm.ping&quot;,
    &quot;params&quot; : []
}' -H 'content-type:application/json;' 127.0.0.1:9650/ext/bc/2wb1UXxAstB8ywwv4rU2rFCjLgXnhT44hbLPbwpQoGvFb2wRR7/rpc

# {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:{&quot;success&quot;:true},&quot;id&quot;:1}
</code></pre>
<pre><code class="language-bash"># to get genesis block
# &quot;2wb1UXxAstB8ywwv4rU2rFCjLgXnhT44hbLPbwpQoGvFb2wRR7&quot; is the blockchain Id
curl -X POST --data '{
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;id&quot;     : 1,
    &quot;method&quot; : &quot;timestampvm.lastAccepted&quot;,
    &quot;params&quot; : []
}' -H 'content-type:application/json;' 127.0.0.1:9650/ext/bc/2wb1UXxAstB8ywwv4rU2rFCjLgXnhT44hbLPbwpQoGvFb2wRR7/rpc

# {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:{&quot;id&quot;:&quot;SDfFUzkdzWZbJ6YMysPPNEF5dWLp9q35mEMaLa8Ha2w9aMKoC&quot;},&quot;id&quot;:1}

# &quot;2wb1UXxAstB8ywwv4rU2rFCjLgXnhT44hbLPbwpQoGvFb2wRR7&quot; is the blockchain Id
curl -X POST --data '{
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;id&quot;     : 1,
    &quot;method&quot; : &quot;timestampvm.getBlock&quot;,
    &quot;params&quot; : [{&quot;id&quot;:&quot;SDfFUzkdzWZbJ6YMysPPNEF5dWLp9q35mEMaLa8Ha2w9aMKoC&quot;}]
}' -H 'content-type:application/json;' 127.0.0.1:9650/ext/bc/2wb1UXxAstB8ywwv4rU2rFCjLgXnhT44hbLPbwpQoGvFb2wRR7/rpc

# {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:{&quot;block&quot;:{&quot;data&quot;:&quot;0x32596655705939524358&quot;,&quot;height&quot;:0,&quot;parent_id&quot;:&quot;11111111111111111111111111111111LpoYY&quot;,&quot;timestamp&quot;:0}},&quot;id&quot;:1}
</code></pre>
<pre><code class="language-bash"># to propose data
echo 1 | base64 | tr -d \\n
# MQo=

curl -X POST --data '{
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;id&quot;     : 1,
    &quot;method&quot; : &quot;timestampvm.proposeBlock&quot;,
    &quot;params&quot; : [{&quot;data&quot;:&quot;MQo=&quot;}]
}' -H 'content-type:application/json;' 127.0.0.1:9650/ext/bc/2wb1UXxAstB8ywwv4rU2rFCjLgXnhT44hbLPbwpQoGvFb2wRR7/rpc

# {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:{&quot;success&quot;:true},&quot;id&quot;:1}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timestamp-virtual-machine"><a class="header" href="#timestamp-virtual-machine">Timestamp Virtual Machine</a></h1>
<p><a href="https://github.com/ava-labs/timestampvm/actions/workflows/lint_test_build.yml"><img src="https://github.com/ava-labs/timestampvm/actions/workflows/lint_test_build.yml/badge.svg" alt="Lint+Test+Build" /></a></p>
<p>Avalanche is a network composed of multiple blockchains. Each blockchain is an instance of a <a href="https://docs.avax.network/learn/platform-overview#virtual-machines">Virtual Machine (VM)</a>, much like an object in an object-oriented language is an instance of a class. That is, the VM defines the behavior of the blockchain.</p>
<p>TimestampVM defines a blockchain that is a timestamp server. Each block in the blockchain contains the timestamp when it was created along with a 32-byte piece of data (payload). Each block’s timestamp is after its parent’s timestamp. This VM demonstrates capabilities of custom VMs and custom blockchains. For more information, see: <a href="https://docs.avax.network/build/tutorials/platform/create-a-virtual-machine-vm">Create a Virtual Machine</a></p>
<h2 id="running-the-vm"><a class="header" href="#running-the-vm">Running the VM</a></h2>
<p><a href="scripts/run.sh"><code>scripts/run.sh</code></a> automatically installs [avalanchego], sets up a local network,
and creates a <code>timestampvm</code> genesis file. To build and run E2E tests, you need to set the variable <code>E2E</code> before it: <code>E2E=true ./scripts/run.sh 1.7.11</code></p>
<p><em>See <a href="tests/e2e"><code>tests/e2e</code></a> to see how it's set up and how its client requests are made.</em></p>
<pre><code class="language-bash"># to startup a local cluster (good for development)
cd ${HOME}/go/src/github.com/ava-labs/timestampvm
./scripts/run.sh 1.9.3

# to run full e2e tests and shut down cluster afterwards
cd ${HOME}/go/src/github.com/ava-labs/timestampvm
E2E=true ./scripts/run.sh 1.9.3

# inspect cluster endpoints when ready
cat /tmp/avalanchego-v1.9.3/output.yaml
&lt;&lt;COMMENT
endpoint: /ext/bc/2VCAhX6vE3UnXC6s1CBPE6jJ4c4cHWMfPgCptuWS59pQ9vbeLM
logsDir: ...
pid: 12811
uris:
- http://127.0.0.1:9650
- http://127.0.0.1:9652
- http://127.0.0.1:9654
- http://127.0.0.1:9656
- http://127.0.0.1:9658
network-runner RPC server is running on PID 66810...

use the following command to terminate:

pkill -P 66810 &amp;&amp; kill -2 66810 &amp;&amp; pkill -9 -f tGas3T58KzdjLHhBDMnH2TvrddhqTji5iZAMZ3RXs2NLpSnhH

# propose a block
curl -X POST --data '{
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;method&quot;: &quot;timestampvm.proposeBlock&quot;,
    &quot;params&quot;:{
        &quot;data&quot;:&quot;0x01020304000000000000000000000000000000000000000000000000000000003f004e9c&quot;
    },
    &quot;id&quot;: 1
}' -H 'content-type:application/json;' http://127.0.0.1:9652/ext/bc/2W3Gn3E3xKSeHQZP47iybpgH6pk3JRWbNQs9P2FrKvXcHSNteB
&lt;&lt;COMMENT
{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:{&quot;Success&quot;:true},&quot;id&quot;:1}
COMMENT

# view last accepted block
curl -X POST --data '{
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;method&quot;: &quot;timestampvm.getBlock&quot;,
    &quot;params&quot;:{},
    &quot;id&quot;: 1
}' -H 'content-type:application/json;' http://127.0.0.1:9652/ext/bc/2W3Gn3E3xKSeHQZP47iybpgH6pk3JRWbNQs9P2FrKvXcHSNteB
&lt;&lt;COMMENT
{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:{&quot;timestamp&quot;:&quot;1668475950&quot;,&quot;data&quot;:&quot;0x01020304000000000000000000000000000000000000000000000000000000003f004e9c&quot;,&quot;height&quot;:&quot;1&quot;,&quot;id&quot;:&quot;2RbyqtZcr8DWnxWjD2jLaPUsjd2cxMFbjz1kmJjR7gDpp3txvz&quot;,&quot;parentID&quot;:&quot;SdVstz8FpkYxsneD2XQDk2CK7d1EBe4YVqkhftgbvUiyFfeHJ&quot;},&quot;id&quot;:1}
COMMENT

# terminate cluster
pkill -P 66810 &amp;&amp; kill -2 66810 &amp;&amp; pkill -9 -f tGas3T58KzdjLHhBDMnH2TvrddhqTji5iZAMZ3RXs2NLpSnhH
</code></pre>
<h2 id="load-testing-the-vm"><a class="header" href="#load-testing-the-vm">Load Testing the VM</a></h2>
<p>Because <code>TimestampVM</code> is such a lightweight Virtual Machine, it is a great
candidate for testing the raw performance of the <code>ProposerVM</code> wrapper in
AvalancheGo.</p>
<p>To kickoff a load test, all you need to do is run the following command:</p>
<pre><code class="language-bash">./scripts/tests.load.sh 1.9.3
</code></pre>
<p>This will automatically:</p>
<ul>
<li>disable all rate limiting rules in AvalancheGo</li>
<li>activate the ProposerVM immediately (usually activates after 5 minutes on
a new Subnet)</li>
<li>set the ProposerVM block timer to have 0 delay (generate blocks as
fast as possible)</li>
</ul>
<p>When running, you'll see a set of logs printed out indicating the current
number of blocks per second <strong>generated and finalized</strong> on a local network:</p>
<pre><code>INFO[11-18|09:19:58] Stats                                    height=0 avg bps=0.000 last bps=0.000
INFO[11-18|09:20:01] Stats                                    height=261 avg bps=86.795 last bps=87.000
INFO[11-18|09:20:04] Stats                                    height=597 avg bps=99.372 last bps=112.000
INFO[11-18|09:20:07] Stats                                    height=942 avg bps=104.566 last bps=115.000
INFO[11-18|09:20:10] Stats                                    height=1291 avg bps=107.493 last bps=116.333
INFO[11-18|09:20:13] Stats                                    height=1634 avg bps=108.854 last bps=114.333
INFO[11-18|09:20:16] Stats                                    height=1976 avg bps=109.664 last bps=114.000
INFO[11-18|09:20:19] Stats                                    height=2308 avg bps=109.804 last bps=110.667
INFO[11-18|09:20:22] Stats                                    height=2636 avg bps=109.742 last bps=109.333
INFO[11-18|09:20:25] Stats                                    height=2978 avg bps=110.213 last bps=114.000
INFO[11-18|09:20:28] Stats                                    height=3318 avg bps=110.512 last bps=113.333
INFO[11-18|09:20:31] Stats                                    height=3649 avg bps=110.489 last bps=110.333
INFO[11-18|09:20:34] Stats                                    height=3987 avg bps=110.667 last bps=112.667
INFO[11-18|09:20:37] Stats                                    height=4320 avg bps=110.691 last bps=111.000
INFO[11-18|09:20:40] Stats                                    height=4653 avg bps=110.711 last bps=111.000
INFO[11-18|09:20:43] Stats                                    height=4974 avg bps=110.453 last bps=107.000
INFO[11-18|09:20:46] Stats                                    height=5304 avg bps=110.423 last bps=110.000
INFO[11-18|09:20:49] Stats                                    height=5636 avg bps=110.434 last bps=110.667
INFO[11-18|09:20:52] Stats                                    height=5950 avg bps=110.101 last bps=104.667
INFO[11-18|09:20:55] Stats                                    height=6236 avg bps=109.317 last bps=95.333
INFO[11-18|09:20:58] Stats                                    height=6552 avg bps=109.116 last bps=105.333
INFO[11-18|09:21:01] Stats                                    height=6876 avg bps=109.061 last bps=108.000
INFO[11-18|09:21:04] Stats                                    height=7210 avg bps=109.163 last bps=111.333
INFO[11-18|09:21:07] Stats                                    height=7499 avg bps=108.574 last bps=96.333
INFO[11-18|09:21:10] Stats                                    height=7787 avg bps=108.049 last bps=96.000
INFO[11-18|09:21:13] Stats                                    height=8119 avg bps=108.152 last bps=110.667
INFO[11-18|09:21:16] Stats                                    height=8449 avg bps=108.222 last bps=110.000
INFO[11-18|09:21:19] Stats                                    height=8779 avg bps=108.279 last bps=110.000
INFO[11-18|09:21:22] Stats                                    height=9107 avg bps=108.315 last bps=109.333
INFO[11-18|09:21:25] Stats                                    height=9437 avg bps=108.372 last bps=110.000
INFO[11-18|09:21:28] Stats                                    height=9757 avg bps=108.315 last bps=106.667
INFO[11-18|09:21:31] Stats                                    height=10069 avg bps=108.175 last bps=104.000
INFO[11-18|09:21:34] Stats                                    height=10401 avg bps=108.242 last bps=110.667
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-plugins-without-go"><a class="header" href="#writing-plugins-without-go">Writing Plugins Without Go</a></h1>
<p>此文介绍通过非go编程语言来写一个可以与go-plugin兼容的插件。因为go-plugin是通过gRPC来实现的，因此，兼容其他编程语言实现的插件也相对要简单很多。</p>
<p>开发兼容go-plugin的插件想要用到gPRC的相关知识，如果不熟悉gRPC，可以参考<a href="http://www.grpc.io/docs/tutorials/basic/go.html">gRPC Go Tutorial</a>. This alone is enough gRPC knowledge to continue.</p>
<p>This guide will implement the kv example in Python.
Full source code for the examples present in this guide
<a href="https://github.com/hashicorp/go-plugin/tree/master/examples/grpc">is available in the examples/grpc folder</a>.</p>
<h2 id="1-implement-the-service"><a class="header" href="#1-implement-the-service">1. Implement the Service</a></h2>
<p>第一步是实现gRPC，服务于插件中定义的protocol buffers service。这是一个标准的gRPC服务。对于KV型服务，大概是这样的结构：</p>
<pre><code class="language-proto">service KV {
    rpc Get(GetRequest) returns (GetResponse);
    rpc Put(PutRequest) returns (Empty);
}
</code></pre>
<p>Python实现版本如下:</p>
<pre><code class="language-python">class KVServicer(kv_pb2_grpc.KVServicer):
    &quot;&quot;&quot;Implementation of KV service.&quot;&quot;&quot;

    def Get(self, request, context):
        filename = &quot;kv_&quot;+request.key
        with open(filename, 'r') as f:
            result = kv_pb2.GetResponse()
            result.value = f.read()
            return result

    def Put(self, request, context):
        filename = &quot;kv_&quot;+request.key
        value = &quot;{0}\n\nWritten from plugin-python&quot;.format(request.value)
        with open(filename, 'w') as f:
            f.write(value)

        return kv_pb2.Empty()

</code></pre>
<p>这样就实现了service,接下来可以通过标准的gRPC测试机制来测试我们的功能（服务）。</p>
<h2 id="2-serve-the-service"><a class="header" href="#2-serve-the-service">2. Serve the Service</a></h2>
<p>现在先要构建一个gRPC服务器，对外提供我们刚刚实现的服务。</p>
<p>In Python:</p>
<pre><code class="language-python"># 新建server
server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
# 添加service
kv_pb2_grpc.add_KVServicer_to_server(KVServicer(), server)
# 设置监听端口
server.add_insecure_port(':1234')
# 启动服务
server.start()
</code></pre>
<p>服务器可以监听任意的TCP地址 或者 Unix domain socket.go-plugin 运行前提是可靠底层链接，所以最好不要server和client之间最好不要跨网络，即建议本地运行。</p>
<h2 id="3-add-the-grpc-health-checking-service"><a class="header" href="#3-add-the-grpc-health-checking-service">3. Add the gRPC Health Checking Service</a></h2>
<p>go-plugin requires the
<a href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md">gRPC Health Checking Service</a>
to be registered on your server. You must register the status of &quot;plugin&quot; to be SERVING.</p>
<p>The health checking service is used by go-plugin to determine if everything
is healthy with the connection. If you don't implement this service, your
process may be abruptly restarted and your plugins are likely to be unreliable.</p>
<pre><code>health = HealthServicer()
health.set(&quot;plugin&quot;, health_pb2.HealthCheckResponse.ServingStatus.Value('SERVING'))
health_pb2_grpc.add_HealthServicer_to_server(health, server)
</code></pre>
<h2 id="4-output-handshake-information-发出握手消息"><a class="header" href="#4-output-handshake-information-发出握手消息">4. Output Handshake Information 发出握手消息</a></h2>
<p>最后一步，向stdout发出握手信息。go-plugin将会从标准输出stdout中读取一行，然后根据消息确定如何连接我们的插件、使用什么协议，etc.</p>
<p>握手消息结构如下:</p>
<pre><code>CORE-PROTOCOL-VERSION | APP-PROTOCOL-VERSION | NETWORK-TYPE | NETWORK-ADDR | PROTOCOL
</code></pre>
<p>说明:</p>
<ul>
<li>
<p><code>CORE-PROTOCOL-VERSION</code> is the protocol version for go-plugin itself.
The current value is <code>1</code>. Please use this value. Any other value will
cause your plugin to not load.</p>
</li>
<li>
<p><code>APP-PROTOCOL-VERSION</code> is the protocol version for the application data.
This is determined by the application. You must reference the documentation
for your application to determine the desired value.</p>
</li>
<li>
<p><code>NETWORK-TYPE</code> and <code>NETWORK-ADDR</code> are the networking information for
connecting to this plugin. The type must be &quot;unix&quot; or &quot;tcp&quot;. The address
is a path to the Unix socket for &quot;unix&quot; and an IP address for &quot;tcp&quot;.</p>
</li>
<li>
<p><code>PROTOCOL</code> is the named protocol that the connection will use. If this
is omitted (older versions), this is &quot;netrpc&quot; for Go net/rpc. This can
also be &quot;grpc&quot;. This is the protocol that the plugin wants to speak to
the host process with.</p>
</li>
</ul>
<p>一般握手消息示例:</p>
<pre><code>1|1|tcp|127.0.0.1:1234|grpc
</code></pre>
<p>这里唯一想要注意的是第二个 (<code>APP-PROTOCOL-VERISON</code>)，这个是与插件程序相关的，更多细节请参考其他资料，此处不再赘述。</p>
<h2 id="5-完成"><a class="header" href="#5-完成">5. 完成！</a></h2>
<p>And we're done!</p>
<p>Configure the host application (the application you're writing a plugin
for) to execute your Python application. Configuring plugins is specific
to the host application.</p>
<p>For our example, we used an environmental variable, and it looks like this:</p>
<pre><code class="language-sh">$ export KV_PLUGIN=&quot;python plugin.py&quot;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
