<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Snowman VMs</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> 第一章 Avalanche共识协议介绍</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> 第二章 AvalancheGo结构分析</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter2.1.html"><strong aria-hidden="true">2.1.</strong> snowman协议</a></li><li class="chapter-item expanded "><a href="chapter2.2.html"><strong aria-hidden="true">2.2.</strong> snowman协议实现解析</a></li><li class="chapter-item expanded "><a href="chapter2.3.html"><strong aria-hidden="true">2.3.</strong> Avalanche网络</a></li><li class="chapter-item expanded "><a href="SnowmanVMs.html" class="active"><strong aria-hidden="true">2.4.</strong> Snowman VMs</a></li></ol></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> 第三章 VM与AvalancheGo的连接</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> 第四章 创建虚拟机VM</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter4.1.html"><strong aria-hidden="true">4.1.</strong> 时间戳服务器的实现Virtual Machine</a></li><li class="chapter-item expanded "><a href="chapter4.2.html"><strong aria-hidden="true">4.2.</strong> Static API</a></li><li class="chapter-item expanded "><a href="chapter4.3.html"><strong aria-hidden="true">4.3.</strong> API</a></li><li class="chapter-item expanded "><a href="chapter4.4.html"><strong aria-hidden="true">4.4.</strong> 封装运行</a></li></ol></li><li class="chapter-item expanded "><a href="chapter5.html"><strong aria-hidden="true">5.</strong> 第五章 专用EVM开发</a></li><li class="chapter-item expanded "><a href="chapter6.html"><strong aria-hidden="true">6.</strong> 第六章 本地网络模拟ANR</a></li><li class="chapter-item expanded "><a href="chapter7.html"><strong aria-hidden="true">7.</strong> 第七章 本地调试</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> 第八章 生产环境部署</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="snowman-vms"><a class="header" href="#snowman-vms">Snowman VMs</a></h1>
<h2 id="avalanche-subnets摘要说明"><a class="header" href="#avalanche-subnets摘要说明">Avalanche Subnets摘要说明</a></h2>
<p>The Avalanche Network is composed of multiple validator sets and blockchains. A validator set defines a group of validators and their specified weights in the consensus process. A subnet is a validator set working together to achieve consensus on a set of blockchains. Every blockchain is validated by one subnet, and one subnet can validate many blockchains.</p>
<p>There is a special subnet inherent to the Avalanche Network called the Primary Network. The Primary Network is validated by every node on the Avalanche network. All subnets' validator sets are required to be a subset of the Primary Network's validator set. That is, if a validator belongs to a subnet then it also belongs to the Primary Network. The Primary Network validates three blockchains that are inherent to the Avalanche Network: the P-Chain, C-Chain, and X-Chain.</p>
<p>For each blockchain, consensus is driven by the consensus engine. For each subnet, the P-Chain, or Platform Chain, defines the validator set and the set of blockchains that are validated by the subnet.</p>
<p>A blockchain consists of two components: a consensus engine and a Virtual Machine (VM). The consensus engine samples validators, handles the responses, and pushes the results of the completed polls into the consensus <a href="../snow/consensus/">code</a> to decide which containers to Accept/Reject. The VM encodes the application logic for the blockchain. The VM defines the contents of a block, the rules for determining whether a block is valid, the APIs exposed to users, the state transition that occurs if a given block is accepted, and so on.</p>
<p>The consensus engine is general and agnostic to the application semantics of the blockchain. There are two consensus engine implementations in AvalancheGo: Snowman and Avalanche. Snowman provides a consensus engine for linear chains and Avalanche provides a consensus engine for DAGs. These consensus engine implementations can be re-used for multiple different blockchains in the Avalanche ecosystem, and each blockchain actually runs its own independent instance of consensus.</p>
<p>在Avalanche上发布一条区块链，只需要根据要求接口将application业务逻辑实现成为一个VM即可，共识部分交给已有的共识引擎来完成实现。</p>
<p>本文介绍一个运行在snowman consensus engine上的一个 ChainVM 实现的细节。一个在 snowm 上运行的VM，需要实现<code>ChainVM</code>接口。VMs是可复用的，任何区块链都可以运行运行相同的VM,没一条区块链都有自己的状态。这种方式，VM相对于某一个具体对应的运行该VM的区块来说，就好比面向对象编程语言范式中一个类的实例对应于该类。</p>
<h2 id="从consensus-engine-的角度看-snowmanvm"><a class="header" href="#从consensus-engine-的角度看-snowmanvm">从consensus engine 的角度看 SnowmanVM</a></h2>
<p>对应consensus engine 来说，SnowmanVM就是一个黑盒子，是一个有着严格规定的数据处理模块，可以用来创建区块，解析区块，保存区块，同时提供了一些区块处理的方法供引擎调用。</p>
<h3 id="snowman-vm-处理区块的相关功能"><a class="header" href="#snowman-vm-处理区块的相关功能">Snowman VM 处理区块的相关功能</a></h3>
<p>在consensus engine处理共识过程中，需要对应的Snowman VM能够实现以下功能接口，供引擎调用。</p>
<h4 id="build-block创建区块"><a class="header" href="#build-block创建区块">Build Block创建区块</a></h4>
<p>Build block allows the VM to propose a new block to be added to consensus.
VM可以通过一个<code>toEngine</code> channel向engine发送消息（这个channel在VM initialized阶段会分配）。当VM准备创建一个区块的时候，VM可以通过此channel向engine发送给message。例如：如果VM收到一些交易（可能是来自网络gossip或者本节点的API）的时候，VM就会向engine发送一个<code>PendingTxs</code> message 表示VM已准备好数据可以创建一个新的区块。<code>PendingTxs</code> message通知engine,其应该调用<code>BuildBlock()</code>创建区块，以将pending 数据添加到共识中。</p>
<p>VM创建区块的时候，先向engine发消息，再由engine调用VM的<code>BuildBlock()</code>。如此绕一圈意义何在呢？这里需要特别说明的是，在实际工程实现中， Snowman VMs会被包装成 <a href="./proposervm/README.html">Snowman++</a>.顾名思义，Snowman++是一个Snowman的改进版本，用于处理原生的Snowman协议在理论上和实际中的一些小差异导致的性能问题，这个差异就是区块的生成问题，在avalanche协议中，区块虽然会最终达成共识，但是如果不对生成区块的顺序进行控制的话，多个区块共同竞争会造成网络拥堵，网络共识的时间就会比较长这个就是我们说的网络共识性能问题。所以，通过Snowman++进一步进行了优化。</p>
<p>Snowman++的优化思路是：在全网validators中由一个称为soft leader（soft leader不是指定某一个节点，而是从全网validators中通过密码算法推荐的一个节点，不固定）的节点生成区块，如果在规定时间内soft leader没有产出区块，Snowman++ 会平滑的添加可产生区块的节点，如果一直没有新区块产出，进行增加，一直到全网validators都可以产生新区块（这个时候Snowman++就蜕化成Snowman）。</p>
<p>在Snowman++中，并不是每个节点都可以随时的产生新区块（但并没有减弱去中心化），所以每次VM有数据需要写入区块的时候，要先通知engine,有engine根据Snowman++规则确定是否可以生成区块，如果不能，则把数据gossip到全网中让其他节点知道该数据（交易）。如果刚好本节点可以生成区块，则engine 直接调用VM的<code>BuildBlock()</code>。这就意味着engine收到 <code>PendingTxs</code> message就一定会立即调用<code>BuildBlock()</code>。</p>
<p>当consensus engine调用 <code>BuildBlock</code>，VM会在当前的<a href="#set-preference">preferred block</a>块的基础上创建一个新区块。</p>
<h4 id="parse-block"><a class="header" href="#parse-block">Parse Block</a></h4>
<p>Parse block 将[]byte 解析成block对象，同时可以进行区块格式、语法等的检查，确保区块数据符合规则，没有数据错误、丢失。例如，如果解析、反序列化后得到的某一个字段是invalid。则，ParseBlcok就会立即返回一个错误给引擎，引擎就不用再进一步对该区块继续verifing。所有历史区块数据（保存在本地数据库中）都是可以解析的。</p>
<h4 id="getblock"><a class="header" href="#getblock">GetBlock</a></h4>
<p>GetBlock用于向VM获取VM已经知晓的区块，如果区块已经通过verified验证，VM要求返回这个uniquified block一直到该区块被Accept or Reject。当一个区块has been decided(已被Accept或Reject,数据库会保存已经accept的区块)，这个时候就不在需要返回一个uniquifying block,如果区块是被reject,后续也不会要求VM去处理这个区块或者返回该区块。</p>
<h4 id="set-preference"><a class="header" href="#set-preference">Set Preference</a></h4>
<p>VM需要实现一个function <code>SetPreference(blkID ids.ID)</code>。这个是consensus engine需要用于通知VM哪个区块是当前的preferred 区块。VM用Preferred区块作为其区块链的头（方向）。更重要的是当consensus engine calls buildblock的时候，VM需要保证新建的区块的父区块是recently preference。
注意：一般区块下，SetPreference都会用一个没有verified子区块的区块来做 preference。</p>
<h3 id="implementing-the-snowman-vm-block"><a class="header" href="#implementing-the-snowman-vm-block">Implementing the Snowman VM Block</a></h3>
<p>从consensue engine的角度上看，VM的状态state可以定义为一条线性链，该链从创世块开始，一直到最后被接受的区块。</p>
<p>从最新的被共识接受的区块开始，共识可能同时处理着多个区块（其实引擎处理的区块是从最新接受的区块开始加上往后的部分，最新被接受区块之前的历史祖先区块全部都是已经接受的区块，共识引擎不在处理这部分内容）。最新接受的区块开始加上往后的区块的布局为一颗以最新接受块为root的树型结构。</p>
<p>在实践中，看起来是这种结构：</p>
<pre><code>    G
    |
    .
    .
    .
    |
    L
    |
    A
  /   \
 B     C
</code></pre>
<p>这图例中，G -&gt; ... -&gt; L 就是已经被共识接受的线型链，共识引擎将不在处理。</p>
<p>A区块（父区块为L）区块 B and C（两个都以区块A作为父区块）都是consensus engine处理的内容。</p>
<p>从engine的角度看来，我们将这种状态称为ChainVM的一种可能配置，我们将试图明确定义从这个配置到下一个配置的一系列可能的步骤，这些步骤必须由ChainVM正确实现。</p>
<p>consensus engine配置好各种参数正常运行后，主要做三件操作：</p>
<ol>
<li>
<p>engine将尝试verify验证一个区块，验证其父区块是否是最新接受的区块或者是在共识处理池中的区块。（如果是历史区块不符合规则）</p>
</li>
<li>
<p>共识engine调整其preference</p>
</li>
<li>
<p>共识engine 就根据投票结果达成共识，然后对一系列的区块进行Accept/Reject操作。</p>
</li>
</ol>
<p>如果共识引擎达到某一个共识, 然后就对一个或者多个区块开始执行如下操作:</p>
<ol>
<li>Call Accept on a block</li>
<li>Call Reject on all transitive conflicts</li>
<li>Repeat steps 1-2 until there are no more blocks to accept</li>
</ol>
<p>因此，如果共识处理区（池）区块树（）是在共识处理中的，其结构就是这样：</p>
<pre><code>    L
  /   \
 A     B
 |    / \
 C   D   G
    / \ 
   E   F
</code></pre>
<p>如果engine同时确定了AC为共识分支，共识引擎就执行下面的操作：</p>
<ol>
<li>Accept(A)</li>
<li>Reject(B), Reject(D), Reject(E), Reject(F), and Reject(G)</li>
<li>Accept(C)</li>
</ol>
<p>To see the actual code where Accept/Reject are performed, look <a href="../snow/consensus/snowman/topological.go">这里.</a></p>
<h3 id="block-statuses"><a class="header" href="#block-statuses">Block Statuses</a></h3>
<p>A block's status must be one of <code>Accepted</code>, <code>Rejected</code>, <code>Processing</code>.</p>
<p>A block that is <code>Accepted</code> or <code>Rejected</code> is considered to be <code>Decided</code>.</p>
<h4 id="processing-blocks"><a class="header" href="#processing-blocks">Processing Blocks</a></h4>
<p>如果一个区块的status是<code>Processing</code>，则表示当前有该区块的字节序列，并已经解析成为对象，但是区块还没有被处理。
此外，处于 <code>Processing</code>状态的区块可能已经通过<code>Verify()</code>，也可能还没有，因此一个<code>Processing</code>状态的区块不一定已发到共识引擎中去处理，有可能在等待获取其祖先区块。一个区块发往共识区中处理之前，引擎会先对区块进行<code>Verify()</code>验证。
列如，当一个节点从网络上收到一个节点，它会先调用<code>ParseBlock(blockBytes)</code>得到一个区块对象发给engine。这个时候该区块还没有全面verified，也还没发送到共识处理池子中。需要等engine获取（从网络上）该区块的还未被共识接受所有祖先区块（即追溯到最新共识接受的区块）后，准备将该区块放入共识处理池中的时候，engine就会对该区块及其所有祖先区块进行<code>Verify()</code> ，通过Verify()无错误后，才将该区块加入到共识处理池子中。</p>
<h4 id="accepted-blocks"><a class="header" href="#accepted-blocks">Accepted Blocks</a></h4>
<p>当一个区块被共识引擎处理后认为是<code>Accepted</code>，则表示该区块已经在全网达成共识，写入区块链中。一个Accepted 区块都可以通过VM的<code>GetBlock</code>获取。</p>
<h4 id="rejected-blocks"><a class="header" href="#rejected-blocks">Rejected Blocks</a></h4>
<p>当一个区块被共识引擎<code>Reject</code>之后，就被认为是没有被网络共识接受的区块，就没有必要继续保存，但是从性能的角度考虑，一般不立即删除该信息（记录该区块被reject的信息），会保存在缓存区一段时间，然后区块链（共识接受）高度已经超过该rejected区块的高度之后，就可以删除相关处理记录了，因为共识网络不会再处理区块高度低于当前区块链高度的区块。</p>
<h3 id="uniquifying-blocks"><a class="header" href="#uniquifying-blocks">Uniquifying Blocks</a></h3>
<p>该段内容理解（版本一）！！！ 
这一部分似乎是在讲统一区块的问题，因为avalanche snowman处理共识是在区块级别层面的，就是对区块进行投票确认。但是区块中的内容需要在共识实践层面解决，否则区块在生成阶段会造成混乱。
通俗说来，就是snowman是用于在大家就全网一部分区块的共识达成过程上。但是全网的交易打包成统一的区块的事情上不是snowman可以处理的。
一个节点收到的区块数据是可以重新拆分加入更多交易的。
！！！</p>
<p>该段内容理解（版本二）！！！
如果区块还在共识处理中，这个时候VM及其相关数据库是没有记录进入区块的（也就是还没有加入区块链）。但是如果引擎有需要，向VM发起询问，VM也应该要能回复一个和引擎统一的区块。
也就是说，该区块是属于缓存中的区块，还在共识处理中，这个时候VM和引擎在涉及到这些区块的处理时，都是统一操作缓存区的区块数据，所以叫Uniquifying blocks。
！！！</p>
<p>当区块是在共识处理状态时，要求VM返回该区块的时候，需要返回的是 a unique reference to blocks。
也就是说，在VM的角度看来，当一个区块在 <code>Verify()</code>正确通过之后，但是还没有 <code>Accept()</code> or <code>Reject()</code>的时候，就是在共识处理状态，这个时候就区块还没有达成共识，不能写入数据库，是属于在缓存区中的数据，这个时候需要VM返回该区块的话，VM就应返回一个缓存区的一个的reference,并给到engine。</p>
<p>如果一个区块是processing中的，VM返回这些区块的时候是和engine返回的区块是相同区块的引用。</p>
<p>如果一个区块已经被共识处理（被接受或者被拒绝），engine 就不会在对这个区块<code>Verify()</code>, <code>Accept()</code>, or <code>Reject()</code>。因为这个区块再也不会被共识引擎处理。这个时候返回一个non-unique区块是安全的。</p>
<p>如果一个区块正在processing,but hasn't been verified(i.e.区块还没有被发往共识处理池)，这个时候，it is safe to return a non-unique block.
Verify()本质是验证区块的正确性，即是各个方面数据格式、交易逻辑都是符合规定、符合业务定义的逻辑，一个通过verify的区块，就是一个等待共识写入的合格区块，如果共识达成，区块就会写入区块链，作为最新接受的block,如果共识拒绝，就丢弃。</p>
<p>只要一通过<code>Verify()</code>。VM后续返回的就是该同一区块的引用。
着意味着VM需要处理关于统一缓存区区块的相关细节业务。所以./components/chain/ package就是用来处理、实现一个高效的缓存模块。rpcchainvm中就用到该模块来实现。</p>
<h2 id="创建-apis"><a class="header" href="#创建-apis">创建 APIs</a></h2>
<p>VM还需要实现 <code>CreateHandlers()</code>，用于创建返回一个(路径——&gt;http handler)的map列表,用于向节点API server中添加关于该条链的各种API。这样节点就可以向外部提供在该区块链上的相关操作交互API。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter2.3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="chapter3.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter2.3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="chapter3.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
